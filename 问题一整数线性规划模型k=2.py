#!/usr/bin/env python
# coding: utf-8

# k=2的四组结果 使用时，将某一组c取消注释，并更改m的值，再运行即可求解线性规划模型。

import cvxpy as cp
import numpy as np
c=[
    #case2: m=[9000,4000] 12460 
    #[156,10+210+16,10+84+32],
    #[144,14+192+12,14+90+24]

    #case2:m=[5000,9000] 12345 
    #[114+117+16,16+207+16,36],
    #[110+105+12,12+207+12,40]

    #case2 m=[6000,7000] 12730
    #[130,10+16+147+16,26+138+32],
    #[122,10+12+135+12,26+150+24]

    #case1 m=[7000,0] 10470
    #[98,243,36],
    #[98,211,40]
]
c = np.array(c)
m=[[9000,4000]]
m=np.array(m)

x = cp.Variable((2,3),integer=True)
obj = cp.Maximize(10000-5*x[0,0]-10*x[1,0]-10*(x[0,1]+x[0,2])-20*(x[1,1]+x[1,2])+m[0,0]+m[0,1]
                 +2.5*(x[0,0]-c[0,0]+x[0,1]-c[0,1]+x[0,2]-c[0,2])
                 +5*(x[1,0]-c[1,0]+x[1,1]-c[1,1]+x[1,2]-c[1,2]))
cons = [
    3*x[0,0]+2*x[1,0]<=1200,
    5*x[0,0]+10*x[1,0]<=10000,
    x[0,0]-c[0,0]>=0,
    x[0,0]-c[0,0]+x[0,1]-c[0,1]>=0,
    x[0,0]-c[0,0]+x[0,1]-c[0,1]+x[0,2]-c[0,2]>=0,
    x[1,0]-c[1,0]>=0,
    x[1,0]-c[1,0]+x[1,1]-c[1,1]>=0,
    x[1,0]-c[1,0]+x[1,1]-c[1,1]+x[1,2]-c[1,2]>=0,
    3*(x[0,0]-c[0,0]+x[0,1])+2*(x[1,0]-c[1,0]+x[1,1])<=1200,
    3*(x[0,0]-c[0,0]+x[0,1]-c[0,1]+x[0,2])+2*(x[1,0]-c[1,0]+x[1,1]-c[1,1]+x[1,2])<=1200,
    x>=0
]
prob = cp.Problem(obj,cons)
prob.solve(solver = 'GLPK_MI')

print(x.value)
print(prob.value)